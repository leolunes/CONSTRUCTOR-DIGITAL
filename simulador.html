<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Simulador de Cargas del Hogar</title>
  <style>
    :root{
      --bg:#0b1220; --card:#111a2e; --text:#e7eefc; --muted:#a7b4d6;
      --line:rgba(255,255,255,.10); --accent:#5eead4;
      --good:#10b981; --warn:#f59e0b; --risk:#f97316; --crit:#f43f5e;
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:1300px;margin:0 auto;padding:18px;}
    .hero{border:1px solid var(--line);border-radius:18px;padding:14px;background:linear-gradient(135deg, rgba(94,234,212,.10), rgba(99,102,241,.08));}
    h1{margin:0 0 6px;font-size:26px;}
    .sub{margin:0;color:var(--muted);line-height:1.4}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);color:var(--muted);font-size:12px;margin-right:8px;}
    .grid{display:grid;grid-template-columns:1fr;gap:14px;margin-top:14px;}
    @media(min-width:1040px){.grid{grid-template-columns:360px 1fr 360px;}}
    .card{background:var(--card);border:1px solid var(--line);border-radius:18px;padding:14px;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;align-items:center;}
    button{border:0;border-radius:14px;padding:11px 14px;font-weight:950;cursor:pointer;}
    .primary{background:var(--accent);color:#071018;}
    .ghost{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,.18);}
    .dangerBtn{background:rgba(244,63,94,.14);border:1px solid rgba(244,63,94,.35);color:#fecdd3;}
    .mini{margin-top:12px;border:1px solid var(--line);border-radius:16px;padding:12px;background:rgba(255,255,255,.03);}
    .mini h3{margin:0 0 8px;font-size:14px;}
    .small{font-size:13px;color:var(--muted);line-height:1.45;}
    .tag{display:inline-block;font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);color:var(--muted);}
    label{font-weight:850;font-size:13px;}
    input, select, textarea{
      width:100%;box-sizing:border-box;background:rgba(255,255,255,.04);color:var(--text);
      border:1px solid rgba(255,255,255,.14);border-radius:12px;padding:10px 12px;outline:none;
    }
    textarea{min-height:78px;resize:vertical;}
    .fieldgrid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px;}
    .palette{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px;}
    .loadCard{
      border:1px dashed rgba(255,255,255,.22);
      border-radius:14px;padding:10px;background:rgba(255,255,255,.02);
      cursor:grab;
    }
    .loadCard:active{cursor:grabbing;}
    .loadTitle{font-weight:950;margin:0 0 4px;font-size:13px;}
    .hint{margin:0;color:var(--muted);font-size:12px;line-height:1.35}
    .canvasWrap{position:relative;}
    canvas{width:100%;height:auto;border-radius:18px;border:1px solid var(--line);background:rgba(255,255,255,.02);}
    .overlayHelp{
      position:absolute;left:12px;top:12px;right:12px;
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
      pointer-events:none;
    }
    .badge{
      pointer-events:none;
      font-size:12px;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.18);color:var(--muted);background:rgba(0,0,0,.18)
    }
    .statusRow{display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px;}
    .meter{
      border:1px solid rgba(255,255,255,.14);border-radius:14px;padding:10px;background:rgba(255,255,255,.02);
      display:flex;justify-content:space-between;align-items:center;gap:8px;
    }
    .dot{width:10px;height:10px;border-radius:999px;background:var(--good);box-shadow:0 0 0 3px rgba(16,185,129,.16);}
    .dot.warn{background:var(--warn);box-shadow:0 0 0 3px rgba(245,158,11,.16);}
    .dot.risk{background:var(--risk);box-shadow:0 0 0 3px rgba(249,115,22,.16);}
    .dot.crit{background:var(--crit);box-shadow:0 0 0 3px rgba(244,63,94,.16);}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .warnBar{display:none;margin-top:10px;padding:10px 12px;border-radius:12px;border:1px solid rgba(245,158,11,.35);background:rgba(245,158,11,.12);color:#fcd34d;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="hero">
    <h1 id="t">Simulador</h1>
    <p class="sub" id="d"></p>
    <div style="margin-top:10px">
      <span class="pill" id="pSaved">Estado: ‚Äî</span>
      <span class="pill" id="pWeek">Escenario: laboratorio</span>
      <span class="pill">Arrastra cargas ‚Üí suelta sobre viga/columna/nudo</span>
    </div>
    <div id="pdfWarn" class="warnBar">No se pudo cargar jsPDF (CDN). Verifica conexi√≥n.</div>
  </div>

  <div class="grid">
    <!-- Izquierda: paleta -->
    <div class="card">
      <div class="row">
        <b id="paletteTitle">Paleta de cargas</b>
        <span class="tag" id="saveHint">Se guarda localmente</span>
      </div>

      <div class="mini">
        <div class="small">
          Arrastra una carga y su√©ltala en una zona del p√≥rtico. Luego selecci√≥nala para editar magnitud, direcci√≥n y estado de transferencia.
        </div>
      </div>

      <div class="palette" id="palette"></div>

      <div class="btns">
        <button class="ghost" id="btnExportScenario">Exportar escenario (JSON)</button>
        <button class="dangerBtn" id="btnReset">Borrar escenario</button>
      </div>
    </div>

    <!-- Centro: simulaci√≥n -->
    <div class="card">
      <div class="row">
        <b>Laboratorio ‚Äî P√≥rtico</b>
        <span class="pill">Momentos + Fisuras + Transferencia</span>
      </div>

      <div class="canvasWrap">
        <canvas id="cv" width="980" height="640"></canvas>
        <div class="overlayHelp">
          <span class="badge" id="badgeEq">‚àëFy=0 ¬∑ ‚àëFx=0 ¬∑ ‚àëM=0 (ideal)</span>
          <span class="badge" id="badgeHint">Selecciona una carga: clic sobre ficha</span>
        </div>
      </div>

      <div class="btns">
        <button class="primary" id="btnPdf">Capturar PDF del escenario</button>
        <button class="ghost" id="btnClearLoads">Quitar todas las cargas</button>
      </div>

      <div class="mini">
        <h3 id="metricsTitle">Indicadores (pedag√≥gicos)</h3>
        <div class="small">
          Estos n√∫meros no son ‚Äúingenier√≠a real‚Äù: son una traducci√≥n pedag√≥gica del libro (peso, empuje, momento y concentraci√≥n).
        </div>
        <div class="fieldgrid" style="margin-top:10px">
          <div class="meter">
            <div>
              <b>‚àëFy (peso vertical)</b><div class="small">Suma de cargas verticales activas</div>
            </div>
            <div class="mono" id="mFy">0</div>
          </div>
          <div class="meter">
            <div>
              <b>‚àëFx (empuje horizontal)</b><div class="small">Suma de cargas horizontales activas</div>
            </div>
            <div class="mono" id="mFx">0</div>
          </div>
          <div class="meter">
            <div>
              <b>‚àëM (momento)</b><div class="small">Rotaci√≥n por mala alineaci√≥n/transferencia</div>
            </div>
            <div class="mono" id="mM">0</div>
          </div>
        </div>
      </div>

      <div class="mini" id="reportBox">
        <h3>Reporte del escenario</h3>
        <div class="small" id="reportText">‚Äî</div>
        <div class="small" style="margin-top:10px">
          üìñ <span id="v1q"></span> <span class="muted" id="v1r"></span>
        </div>
      </div>
    </div>

    <!-- Derecha: carga seleccionada -->
    <div class="card">
      <div class="row">
        <b id="selectedTitle">Carga seleccionada</b>
        <span class="tag" id="selTag">Ninguna</span>
      </div>

      <div class="mini" id="selEmpty">
        <div class="small">Haz clic en una ficha de carga dentro del p√≥rtico para ver y editar sus par√°metros.</div>
      </div>

      <div class="mini" id="selPanel" style="display:none">
        <div class="fieldgrid">
          <div>
            <label>Nombre</label>
            <input id="sName" />
          </div>
          <div>
            <label>Zona (d√≥nde cay√≥)</label>
            <select id="sZone"></select>
          </div>
          <div>
            <label>Tipo</label>
            <select id="sType"></select>
          </div>
          <div>
            <label>Direcci√≥n</label>
            <select id="sDir"></select>
          </div>
          <div>
            <label>Magnitud (1‚Äì20)</label>
            <input id="sMag" type="number" min="1" max="20" />
          </div>
          <div>
            <label>Transferencia</label>
            <select id="sTransfer"></select>
          </div>
          <div style="grid-column:1/-1">
            <label>Nota</label>
            <textarea id="sNote" placeholder="Qu√© lo detona / c√≥mo se manifiesta / qu√© se repite"></textarea>
          </div>
        </div>

        <div class="btns">
          <button class="ghost" id="btnTransferFix">Marcar ‚Äútransferencia correcta‚Äù</button>
          <button class="dangerBtn" id="btnDeleteSel">Eliminar carga</button>
        </div>
      </div>

      <div class="mini">
        <h3>Fisuras (por concentraci√≥n)</h3>
        <div class="statusRow" id="fisuras"></div>
        <div class="small" style="margin-top:8px">
          Lectura: microfisura ‚Üí grieta activa ‚Üí cr√≠tica. No es condena: es **alerta**.
        </div>
      </div>
    </div>
  </div>
</div>

<!-- jsPDF -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<script>
  const JSON_PATH = "simulador.json";
  const LOGO_PATH = "logo.png";
  const STORAGE_KEY = "simulador_cargas_hogar_v1";

  let DATA=null;
  let logoDataUrl=null;

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  // UI elements
  const tEl = document.getElementById("t");
  const dEl = document.getElementById("d");
  const paletteEl = document.getElementById("palette");
  const pSaved = document.getElementById("pSaved");
  const pdfWarn = document.getElementById("pdfWarn");

  const mFy = document.getElementById("mFy");
  const mFx = document.getElementById("mFx");
  const mM  = document.getElementById("mM");

  const reportText = document.getElementById("reportText");
  const v1q = document.getElementById("v1q");
  const v1r = document.getElementById("v1r");

  const selTag = document.getElementById("selTag");
  const selEmpty = document.getElementById("selEmpty");
  const selPanel = document.getElementById("selPanel");

  const sName = document.getElementById("sName");
  const sZone = document.getElementById("sZone");
  const sType = document.getElementById("sType");
  const sDir  = document.getElementById("sDir");
  const sMag  = document.getElementById("sMag");
  const sTransfer = document.getElementById("sTransfer");
  const sNote = document.getElementById("sNote");

  const fisurasEl = document.getElementById("fisuras");

  const btnPdf = document.getElementById("btnPdf");
  const btnReset = document.getElementById("btnReset");
  const btnClearLoads = document.getElementById("btnClearLoads");
  const btnExportScenario = document.getElementById("btnExportScenario");
  const btnDeleteSel = document.getElementById("btnDeleteSel");
  const btnTransferFix = document.getElementById("btnTransferFix");

  // State
  const state = {
    loads: [], // placed loads
    selectedId: null
  };

  // Geometry: zones (in canvas coordinates)
  const ZONES = {
    viga:        { key:"viga",        x:190, y:220, w:600, h:60  },
    columna:     { key:"columna",     x:240, y:290, w:80,  h:280 },
    nudo:        { key:"nudo",        x:240, y:220, w:120, h:120 },
    interseccion:{ key:"interseccion",x:680, y:520, w:120, h:60  },
    cimiento:    { key:"cimiento",    x:140, y:570, w:700, h:40  }
  };

  function uid(){
    return (crypto.randomUUID ? crypto.randomUUID() : (Date.now()+"_"+Math.random().toString(16).slice(2)));
  }

  function save(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    pSaved.textContent = "Estado: guardado";
    setTimeout(()=> pSaved.textContent = "Estado: local (sin servidor)", 800);
  }

  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const payload = JSON.parse(raw);
      if(Array.isArray(payload.loads)) state.loads = payload.loads;
      state.selectedId = payload.selectedId || null;
    }catch(e){}
  }

  function okPdfLib(){
    return !!(window.jspdf && window.jspdf.jsPDF);
  }

  function enumLabel(list, key){
    const item = (list||[]).find(x=>x.key===key);
    return item ? item.label : key;
  }

  function setupSelect(sel, list){
    sel.innerHTML = list.map(x=>`<option value="${x.key}">${x.label}</option>`).join("");
  }

  function setupUI(){
    tEl.textContent = DATA.meta.title;
    dEl.textContent = DATA.meta.description;

    setupSelect(sZone, DATA.enums.zone);
    setupSelect(sType, DATA.enums.loadType);
    setupSelect(sDir,  DATA.enums.direction);
    setupSelect(sTransfer, DATA.enums.transferStatus);

    document.getElementById("paletteTitle").textContent = DATA.ui.paletteTitle;
    document.getElementById("saveHint").textContent = DATA.ui.saveHint;
    document.getElementById("selectedTitle").textContent = DATA.ui.selectedTitle;
    document.getElementById("metricsTitle").textContent = DATA.ui.metricsTitle;

    // verse
    v1q.textContent = DATA.verses.fundamento.quote;
    v1r.textContent = `(${DATA.verses.fundamento.reference})`;

    // palette items
    paletteEl.innerHTML = "";
    DATA.palette.forEach(item=>{
      const div = document.createElement("div");
      div.className = "loadCard";
      div.draggable = true;
      div.dataset.paletteKey = item.key;
      div.innerHTML = `
        <p class="loadTitle">${escapeHtml(item.name)}</p>
        <div style="display:flex;gap:6px;flex-wrap:wrap;margin:6px 0">
          <span class="tag">${escapeHtml(enumLabel(DATA.enums.loadType,item.type))}</span>
          <span class="tag">${escapeHtml(enumLabel(DATA.enums.direction,item.direction))}</span>
          <span class="tag">Magnitud ${item.magnitude}</span>
        </div>
        <p class="hint">${escapeHtml(item.hint||"")}</p>
      `;
      div.addEventListener("dragstart", (e)=>{
        e.dataTransfer.setData("text/plain", JSON.stringify({ paletteKey:item.key }));
      });
      paletteEl.appendChild(div);
    });

    pdfWarn.style.display = okPdfLib() ? "none" : "block";
    pSaved.textContent = "Estado: local (sin servidor)";
  }

  // Drop handling on canvas
  cv.addEventListener("dragover", (e)=>{ e.preventDefault(); });
  cv.addEventListener("drop", (e)=>{
    e.preventDefault();
    const rect = cv.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (cv.width / rect.width);
    const y = (e.clientY - rect.top)  * (cv.height / rect.height);

    let payload=null;
    try{ payload = JSON.parse(e.dataTransfer.getData("text/plain")); }catch(err){}

    if(!payload || !payload.paletteKey) return;

    const proto = DATA.palette.find(p=>p.key===payload.paletteKey);
    if(!proto) return;

    const zoneKey = hitZone(x,y);
    if(!zoneKey){
      alert("Suelta la carga dentro del p√≥rtico (viga, columna o nudo).");
      return;
    }

    const placed = {
      id: uid(),
      name: proto.name,
      type: proto.type,
      direction: proto.direction,
      magnitude: clamp(proto.magnitude,1,20),
      transfer: proto.transfer,
      zone: zoneKey,
      note: "",
      // position for chip display (jitter inside zone)
      px: x,
      py: y
    };

    // Snap to zone center-ish to keep readable
    const z = ZONES[zoneKey];
    placed.px = clamp(x, z.x+16, z.x+z.w-16);
    placed.py = clamp(y, z.y+16, z.y+z.h-16);

    state.loads.unshift(placed);
    state.selectedId = placed.id;
    save();
    syncSelectedUI();
    render();
  });

  // Click select / drag chips inside
  let draggingChip = null;
  let dragOffset = {x:0,y:0};

  cv.addEventListener("mousedown", (e)=>{
    const {x,y} = canvasXY(e);
    const hit = hitChip(x,y);
    if(hit){
      state.selectedId = hit.id;
      draggingChip = hit.id;
      dragOffset.x = x - hit.px;
      dragOffset.y = y - hit.py;
      save();
      syncSelectedUI();
      render();
      return;
    }
    state.selectedId = null;
    draggingChip = null;
    save();
    syncSelectedUI();
    render();
  });

  window.addEventListener("mousemove", (e)=>{
    if(!draggingChip) return;
    const {x,y} = canvasXY(e);
    const load = state.loads.find(l=>l.id===draggingChip);
    if(!load) return;

    const zoneKey = load.zone;
    const z = ZONES[zoneKey];
    load.px = clamp(x - dragOffset.x, z.x+16, z.x+z.w-16);
    load.py = clamp(y - dragOffset.y, z.y+16, z.y+z.h-16);

    render();
  });

  window.addEventListener("mouseup", ()=>{
    if(draggingChip){
      save();
    }
    draggingChip = null;
  });

  function canvasXY(e){
    const rect = cv.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (cv.width / rect.width);
    const y = (e.clientY - rect.top)  * (cv.height / rect.height);
    return {x,y};
  }

  function hitZone(x,y){
    // For drop: only viga/columna/nudo (core)
    for(const k of ["viga","nudo","columna"]){
      const z = ZONES[k];
      if(x>=z.x && x<=z.x+z.w && y>=z.y && y<=z.y+z.h) return k;
    }
    return null;
  }

  function hitChip(x,y){
    // chip rects are computed similarly in draw; approximate by checking near px/py
    for(const l of state.loads){
      const w = 160, h = 32;
      const rx = l.px - w/2, ry = l.py - h/2;
      if(x>=rx && x<=rx+w && y>=ry && y<=ry+h) return l;
    }
    return null;
  }

  // Selected panel
  function getSelected(){
    return state.loads.find(l=>l.id===state.selectedId) || null;
  }

  function syncSelectedUI(){
    const sel = getSelected();
    if(!sel){
      selTag.textContent = "Ninguna";
      selEmpty.style.display = "block";
      selPanel.style.display = "none";
      return;
    }
    selTag.textContent = "Activa";
    selEmpty.style.display = "none";
    selPanel.style.display = "block";

    sName.value = sel.name || "";
    sZone.value = sel.zone;
    sType.value = sel.type;
    sDir.value  = sel.direction;
    sMag.value  = sel.magnitude;
    sTransfer.value = sel.transfer;
    sNote.value = sel.note || "";
  }

  function applySelectedFromUI(){
    const sel = getSelected();
    if(!sel) return;

    sel.name = (sName.value||"").trim() || sel.name;
    sel.zone = sZone.value;
    sel.type = sType.value;
    sel.direction = sDir.value;
    sel.magnitude = clamp(Number(sMag.value||1), 1, 20);
    sel.transfer = sTransfer.value;
    sel.note = (sNote.value||"").trim();

    // Keep chip inside its new zone bounds
    const z = ZONES[sel.zone];
    sel.px = clamp(sel.px, z.x+16, z.x+z.w-16);
    sel.py = clamp(sel.py, z.y+16, z.y+z.h-16);

    save();
    render();
  }

  [sName,sZone,sType,sDir,sMag,sTransfer,sNote].forEach(el=>{
    el.addEventListener("input", applySelectedFromUI);
    el.addEventListener("change", applySelectedFromUI);
  });

  btnDeleteSel.addEventListener("click", ()=>{
    const sel = getSelected();
    if(!sel) return;
    if(!confirm("¬øEliminar esta carga?")) return;
    state.loads = state.loads.filter(l=>l.id!==sel.id);
    state.selectedId = null;
    save();
    syncSelectedUI();
    render();
  });

  btnTransferFix.addEventListener("click", ()=>{
    const sel = getSelected();
    if(!sel) return;
    sel.transfer = "correcta";
    save();
    syncSelectedUI();
    render();
  });

  // Scenario buttons
  btnClearLoads.addEventListener("click", ()=>{
    if(!confirm("¬øQuitar todas las cargas del p√≥rtico?")) return;
    state.loads = [];
    state.selectedId = null;
    save();
    syncSelectedUI();
    render();
  });

  btnReset.addEventListener("click", ()=>{
    if(!confirm("¬øBorrar escenario completo (incluye selecci√≥n)?")) return;
    localStorage.removeItem(STORAGE_KEY);
    state.loads = [];
    state.selectedId = null;
    save();
    syncSelectedUI();
    render();
  });

  btnExportScenario.addEventListener("click", ()=>{
    const payload = {
      meta: { exportedAt: new Date().toISOString(), app: DATA.meta.title },
      loads: state.loads
    };
    const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "escenario_simulador.json";
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // Metrics + fisuras model (pedag√≥gico)
  function compute(){
    const fyLoads = state.loads.filter(l=>l.direction==="vertical");
    const fxLoads = state.loads.filter(l=>l.direction==="horizontal");

    const sumFy = fyLoads.reduce((a,l)=>a+l.magnitude,0);
    const sumFx = fxLoads.reduce((a,l)=>a+l.magnitude,0);

    // Moment model:
    // - vertical load creates moment if transferred incorrectly (eccentricity factor)
    // - horizontal load creates moment proportional to "height" of zone
    let sumM = 0;

    const zoneHeightFactor = {
      viga: 3.0, nudo: 2.4, columna: 2.0, interseccion: 1.0, cimiento: 0.5
    };
    const transferFactor = {
      correcta: 0.35,
      cortada_viga: 1.25,
      cortada_columna: 1.10,
      nudo_tenso: 1.18,
      sin_apoyo: 1.05
    };

    for(const l of state.loads){
      const tf = transferFactor[l.transfer] || 1.0;
      const hf = zoneHeightFactor[l.zone] || 2.0;

      if(l.direction === "horizontal"){
        sumM += l.magnitude * hf * tf;
      }else{
        // vertical: if transferencia no correcta, genera momento adicional por desalineaci√≥n (P‚ÄìŒî pedag√≥gico)
        const extra = (l.transfer==="correcta") ? 0.25 : 0.85;
        sumM += l.magnitude * extra * tf;
      }
    }

    // Concentration per element (fisuras index):
    // distribute differently based on transfer status.
    // Idea: if cut at viga -> viga gets more; if cut at columna -> columna gets more; if nudo tenso -> nudo gets more; sin_apoyo -> interseccion gets more.
    const stress = { viga:0, columna:0, nudo:0, interseccion:0, cimiento:0 };

    for(const l of state.loads){
      const base = l.magnitude * (l.direction==="horizontal" ? 1.2 : 1.0);

      // Where it "lands" increases local stress
      stress[l.zone] += base * 0.55;

      // Transfer logic adds concentration
      switch(l.transfer){
        case "correcta":
          stress.cimiento += base * 0.50;
          stress.columna += base * 0.20;
          stress.viga    += base * 0.15;
          break;
        case "cortada_viga":
          stress.viga += base * 0.85;
          stress.nudo += base * 0.15;
          break;
        case "cortada_columna":
          stress.columna += base * 0.80;
          stress.nudo    += base * 0.20;
          break;
        case "nudo_tenso":
          stress.nudo += base * 0.85;
          stress.viga += base * 0.15;
          break;
        case "sin_apoyo":
          stress.interseccion += base * 0.75;
          stress.viga += base * 0.25;
          break;
      }
    }

    // Normalize stress into 0..100-ish scale for readable sem√°foro
    const scale = 2.0; // tune
    for(const k of Object.keys(stress)) stress[k] = Math.round(stress[k] * scale);

    return { sumFy:Math.round(sumFy), sumFx:Math.round(sumFx), sumM:Math.round(sumM), stress };
  }

  function levelFromStress(v){
    const th = DATA.thresholds.fisura;
    if(v >= th.critica) return { key:"critica", label:"Cr√≠tica", cls:"crit" };
    if(v >= th.activa)  return { key:"activa",  label:"Activa",  cls:"risk" };
    if(v >= th.micro)   return { key:"micro",   label:"Microfisura", cls:"warn" };
    return { key:"ok", label:"Sano", cls:"" };
  }

  function renderFisuras(stress){
    const order = ["cimiento","nudo","interseccion","columna","viga"];
    fisurasEl.innerHTML = "";
    order.forEach(k=>{
      const lvl = levelFromStress(stress[k]);
      const div = document.createElement("div");
      div.className = "meter";
      div.innerHTML = `
        <div style="display:flex;align-items:center;gap:10px">
          <span class="dot ${lvl.cls}"></span>
          <div>
            <b>${escapeHtml(enumLabel(DATA.enums.zone,k))}</b>
            <div class="small">${lvl.label} ¬∑ √çndice ${stress[k]}</div>
          </div>
        </div>
        <span class="tag">${lvl.key.toUpperCase()}</span>
      `;
      fisurasEl.appendChild(div);
    });
  }

  function renderReport(metrics){
    const s = metrics.stress;
    const worst = Object.entries(s).sort((a,b)=>b[1]-a[1])[0];
    const worstKey = worst ? worst[0] : "nudo";
    const worstLvl = worst ? levelFromStress(worst[1]) : levelFromStress(0);

    const recommendations = [];

    if(worstKey === "cimiento"){
      recommendations.push("Volver al fundamento: comuni√≥n real, descarga de peso en Cristo.");
      recommendations.push("Alinear decisiones con el altar (no solo l√≥gica o emoci√≥n).");
    }else if(worstKey === "nudo"){
      recommendations.push("Reforzar congregaci√≥n: conversaci√≥n guiada + acuerdo breve.");
      recommendations.push("Evitar discutir bajo tensi√≥n: pausa + volver + oraci√≥n.");
    }else if(worstKey === "interseccion"){
      recommendations.push("Honrar intersecci√≥n: permitir al Esp√≠ritu sostener el alma (reposo, libertad).");
      recommendations.push("Reducir control humano que reemplaza apoyo m√≥vil.");
    }else if(worstKey === "columna"){
      recommendations.push("Columna: transferir al fundamento (no absorber en silencio).");
      recommendations.push("Comuni√≥n diaria y decisiones desde el altar (no control/evasi√≥n).");
    }else if(worstKey === "viga"){
      recommendations.push("Viga: expresar para canalizar (no retener).");
      recommendations.push("Nombrar la carga sin culpa y transferirla: viga‚Üícolumna‚Üícimiento.");
    }

    // Also interpret equations
    const eq = [];
    eq.push(`‚àëFy=${metrics.sumFy} (peso) ¬∑ ‚àëFx=${metrics.sumFx} (empuje) ¬∑ ‚àëM=${metrics.sumM} (rotaci√≥n)`);
    if(metrics.sumM > 90) eq.push("Lectura: hay rotaci√≥n alta ‚Üí falta de anclaje/alineaci√≥n o mala transferencia.");
    else if(metrics.sumM > 50) eq.push("Lectura: momento moderado ‚Üí revisar nudo y ruta de descarga.");
    else eq.push("Lectura: momento bajo ‚Üí el sistema est√° absorbiendo con orden (mantener).");

    reportText.innerHTML = `
      <div><b>Zona m√°s exigida:</b> <span class="tag">${escapeHtml(enumLabel(DATA.enums.zone, worstKey))}</span> ‚Üí <b class="${worstLvl.cls==='crit'?'': ''}">${worstLvl.label}</b> (√çndice ${worst[1]||0})</div>
      <div style="margin-top:8px" class="mono">${escapeHtml(eq.join("  |  "))}</div>
      <div style="margin-top:10px"><b>Recomendaciones:</b></div>
      <ul style="margin:8px 0 0;padding-left:18px;line-height:1.45;color:var(--text)">
        ${recommendations.map(r=>`<li>${escapeHtml(r)}</li>`).join("")}
      </ul>
      <div class="small" style="margin-top:8px;color:var(--muted)">
        üìñ ${escapeHtml(DATA.verses.equilibrio.quote)} (${escapeHtml(DATA.verses.equilibrio.reference)})
      </div>
    `;
  }

  // Drawing
  function drawP√≥rtico(metrics){
    ctx.clearRect(0,0,cv.width,cv.height);

    // Background grid subtle
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#ffffff";
    for(let x=0;x<cv.width;x+=40){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke();
    }
    for(let y=0;y<cv.height;y+=40){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke();
    }
    ctx.restore();

    // Draw foundation
    drawZone(ZONES.cimiento, "CIMIENTO (Cristo)", metrics.stress.cimiento);

    // Draw column + beam + node + interseccion
    drawZone(ZONES.columna, "COLUMNA (Var√≥n)", metrics.stress.columna);
    drawZone(ZONES.viga, "VIGA (Mujer)", metrics.stress.viga);
    drawZone(ZONES.nudo, "NUDO (Congregaci√≥n)", metrics.stress.nudo);
    drawZone(ZONES.interseccion, "INTERSECCI√ìN (Esp√≠ritu)", metrics.stress.interseccion);

    // Connectors (visual)
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 4;
    // column to foundation
    ctx.beginPath();
    ctx.moveTo(ZONES.columna.x+ZONES.columna.w/2, ZONES.columna.y+ZONES.columna.h);
    ctx.lineTo(ZONES.columna.x+ZONES.columna.w/2, ZONES.cimiento.y);
    ctx.stroke();
    // beam to node
    ctx.beginPath();
    ctx.moveTo(ZONES.viga.x, ZONES.viga.y+ZONES.viga.h/2);
    ctx.lineTo(ZONES.nudo.x+ZONES.nudo.w, ZONES.nudo.y+ZONES.nudo.h/2);
    ctx.stroke();
    // node to column
    ctx.beginPath();
    ctx.moveTo(ZONES.nudo.x+ZONES.nudo.w/2, ZONES.nudo.y+ZONES.nudo.h);
    ctx.lineTo(ZONES.columna.x+ZONES.columna.w/2, ZONES.columna.y);
    ctx.stroke();
    // interseccion under beam (support)
    ctx.beginPath();
    ctx.moveTo(ZONES.interseccion.x+ZONES.interseccion.w/2, ZONES.interseccion.y);
    ctx.lineTo(ZONES.interseccion.x+ZONES.interseccion.w/2, ZONES.viga.y+ZONES.viga.h);
    ctx.stroke();
    ctx.restore();

    // Draw transfer arrows (hint)
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(94,234,212,.9)";
    ctx.lineWidth = 2;
    arrow(ZONES.viga.x+ZONES.viga.w*0.25, ZONES.viga.y+ZONES.viga.h+10, ZONES.nudo.x+ZONES.nudo.w/2, ZONES.nudo.y+ZONES.nudo.h+10);
    arrow(ZONES.nudo.x+ZONES.nudo.w/2, ZONES.nudo.y+ZONES.nudo.h+10, ZONES.columna.x+ZONES.columna.w/2, ZONES.columna.y+ZONES.columna.h*0.6);
    arrow(ZONES.columna.x+ZONES.columna.w/2, ZONES.cimiento.y-10, ZONES.columna.x+ZONES.columna.w/2, ZONES.cimiento.y+ZONES.cimiento.h/2);
    ctx.restore();

    // Draw placed load chips
    for(const l of state.loads){
      drawChip(l, l.id===state.selectedId);
    }
  }

  function drawZone(z, label, stressValue){
    const lvl = levelFromStress(stressValue||0);

    // zone bg
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,.03)";
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.lineWidth = 2;
    roundRect(z.x,z.y,z.w,z.h,16,true,true);

    // stress border color
    let col = "rgba(16,185,129,.55)";
    if(lvl.cls==="warn") col = "rgba(245,158,11,.65)";
    if(lvl.cls==="risk") col = "rgba(249,115,22,.70)";
    if(lvl.cls==="crit") col = "rgba(244,63,94,.70)";
    ctx.strokeStyle = col;
    ctx.lineWidth = 3;
    roundRect(z.x+2,z.y+2,z.w-4,z.h-4,16,false,true);

    // label
    ctx.fillStyle = "rgba(231,238,252,.95)";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(label, z.x+14, z.y+24);

    ctx.fillStyle = "rgba(167,180,214,.95)";
    ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(`√çndice ${stressValue||0} ¬∑ ${lvl.label}`, z.x+14, z.y+44);

    ctx.restore();
  }

  function drawChip(l, selected){
    const w = 160, h = 32;
    const x = l.px - w/2, y = l.py - h/2;

    // color by direction
    let chip = "rgba(94,234,212,.20)";
    if(l.direction==="horizontal") chip = "rgba(99,102,241,.18)";

    // border by transfer
    let border = "rgba(255,255,255,.18)";
    if(l.transfer==="correcta") border = "rgba(16,185,129,.60)";
    if(l.transfer==="nudo_tenso") border = "rgba(245,158,11,.60)";
    if(l.transfer==="cortada_viga" || l.transfer==="cortada_columna") border = "rgba(249,115,22,.62)";
    if(l.transfer==="sin_apoyo") border = "rgba(244,63,94,.62)";

    ctx.save();
    ctx.fillStyle = chip;
    ctx.strokeStyle = border;
    ctx.lineWidth = selected ? 3 : 2;
    roundRect(x,y,w,h,12,true,true);

    ctx.fillStyle = "rgba(231,238,252,.95)";
    ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const name = truncate(l.name, 18);
    ctx.fillText(name, x+10, y+20);

    ctx.fillStyle = "rgba(167,180,214,.95)";
    ctx.font = "700 11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.fillText(String(l.magnitude), x+w-26, y+20);

    ctx.restore();
  }

  function arrow(x1,y1,x2,y2){
    const head = 8;
    const dx = x2-x1, dy = y2-y1;
    const ang = Math.atan2(dy,dx);
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head*Math.cos(ang - Math.PI/6), y2 - head*Math.sin(ang - Math.PI/6));
    ctx.lineTo(x2 - head*Math.cos(ang + Math.PI/6), y2 - head*Math.sin(ang + Math.PI/6));
    ctx.closePath();
    ctx.stroke();
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
  function truncate(s,n){ s=String(s||""); return s.length>n ? s.slice(0,n-1)+"‚Ä¶" : s; }
  function escapeHtml(str){
    return String(str||"").replace(/[&<>"']/g, s => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[s]));
  }

  // Render loop
  function render(){
    const metrics = compute();
    mFy.textContent = metrics.sumFy;
    mFx.textContent = metrics.sumFx;
    mM.textContent  = metrics.sumM;

    renderFisuras(metrics.stress);
    renderReport(metrics);
    drawP√≥rtico(metrics);
  }

  // PDF capture
  async function loadLogo(){
    try{
      const res = await fetch(LOGO_PATH, { cache:"no-store" });
      if(!res.ok) return null;
      const blob = await res.blob();
      return await new Promise(resolve=>{
        const fr = new FileReader();
        fr.onload = ()=> resolve(fr.result);
        fr.onerror = ()=> resolve(null);
        fr.readAsDataURL(blob);
      });
    }catch(e){ return null; }
  }

  async function exportPdf(){
    if(!okPdfLib()){
      pdfWarn.style.display = "block";
      return;
    }
    const metrics = compute();
    if(logoDataUrl===null) logoDataUrl = await loadLogo();

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({unit:"pt", format:"letter"});
    const W = doc.internal.pageSize.getWidth();
    const H = doc.internal.pageSize.getHeight();
    const M = 44;

    // Title band
    doc.setFillColor(22,33,58);
    doc.rect(0,0,W,90,"F");
    doc.setTextColor(255,255,255);
    doc.setFont("helvetica","bold");
    doc.setFontSize(18);
    doc.text("SIMULADOR DE CARGAS DEL HOGAR ‚Äî Escenario", M, 52);

    if(logoDataUrl){
      try{ doc.addImage(logoDataUrl,"PNG", W-M-48, 22, 48, 48); }catch(e){}
    }

    doc.setFont("helvetica","normal");
    doc.setFontSize(11);
    doc.setTextColor(210,230,255);
    doc.text("Captura del p√≥rtico + indicadores (pedag√≥gicos)", M, 74);

    // Canvas image
    const img = cv.toDataURL("image/png", 1.0);
    const imgW = W - M*2;
    const imgH = imgW * (cv.height / cv.width);
    doc.setFillColor(255,255,255);
    doc.roundedRect(M, 110, imgW, imgH+18, 12, 12, "F");
    doc.addImage(img, "PNG", M, 120, imgW, imgH);

    // Indicators box
    const y2 = 130 + imgH + 18;
    doc.setFillColor(245,247,255);
    doc.roundedRect(M, y2, imgW, 120, 12, 12, "F");
    doc.setTextColor(22,33,58);
    doc.setFont("helvetica","bold"); doc.setFontSize(12);
    doc.text("Indicadores (pedag√≥gicos)", M+14, y2+28);
    doc.setFont("helvetica","normal"); doc.setFontSize(11);
    doc.text(`‚àëFy (peso): ${metrics.sumFy}`, M+14, y2+52);
    doc.text(`‚àëFx (empuje): ${metrics.sumFx}`, M+14, y2+72);
    doc.text(`‚àëM (momento): ${metrics.sumM}`, M+14, y2+92);

    // Fisuras summary
    const s = metrics.stress;
    const worst = Object.entries(s).sort((a,b)=>b[1]-a[1])[0];
    const worstKey = worst[0];
    const worstVal = worst[1];
    doc.setFont("helvetica","bold");
    doc.text(`Zona m√°s exigida: ${enumLabel(DATA.enums.zone, worstKey)} (√çndice ${worstVal})`, M+14, y2+112);

    // Footer verse
    doc.setTextColor(90,102,130);
    doc.setFont("helvetica","normal"); doc.setFontSize(9);
    doc.text(`üìñ ${DATA.verses.fundamento.quote} (${DATA.verses.fundamento.reference})`, M, H-18);

    doc.save("simulador_cargas_escenario.pdf");
  }

  btnPdf.addEventListener("click", exportPdf);

  // Init
  async function init(){
    const res = await fetch(JSON_PATH, {cache:"no-store"});
    if(!res.ok) throw new Error("No se pudo cargar simulador.json");
    DATA = await res.json();

    setupUI();
    load();
    syncSelectedUI();
    render();

    pdfWarn.style.display = okPdfLib() ? "none" : "block";
  }

  init().catch(err=>{
    document.body.innerHTML = `<div style="padding:22px;color:#fda4af"><b>Error:</b> ${err.message}<br><span style="color:#a7b4d6">Aseg√∫rate de que simulador.json est√© en la misma carpeta.</span></div>`;
  });
</script>
</body>
</html>